---
interface GitHubContentsConfig {
  owner: string;
  repo: string;
  branch: string;
  path: string;
  days?: number;
  linkStyle?: "blob" | "raw";
  dataUrl?: string;
}

export interface Props {
  title?: string;
  accentColor?: string;
  github?: GitHubContentsConfig;
}

const {
  title = "Recent Test Results",
  accentColor = "#22c55e", // green for passed
  github,
} = Astro.props as Props;
---

<div class="mt-4" data-trg-container>
  <div class="flex items-center justify-between">
    <h4 class="text-lg font-semibold text-gray-900">{title}</h4>
  </div>

  <div
    class="mt-3 p-4 bg-white border border-gray-200 rounded-lg"
    data-trg-root
    data-github={github ? JSON.stringify(github) : ""}
    data-accent={accentColor}
  >
    <div class="text-sm text-gray-500" data-trg-status>Loading results…</div>
    <div class="mt-3" data-trg-graph hidden></div>
  </div>
  <div class="mt-2 text-[11px] text-gray-500">Click a bar to open that run’s JSON.</div>
  <div class="mt-1 flex items-center gap-3 text-[11px] text-gray-600">
    <span class="inline-flex items-center gap-1"><span class="inline-block w-3 h-3 rounded" style={`background:${accentColor}`}></span> Passed</span>
    <span class="inline-flex items-center gap-1"><span class="inline-block w-3 h-3 rounded bg-red-500"></span> Failed</span>
  </div>
  
</div>

<script type="module">
  function initOne(root) {
    if (!root || root.dataset.trgInitialized) return;
    root.dataset.trgInitialized = '1';

    const statusEl = root.querySelector('[data-trg-status]');
    const graphEl = root.querySelector('[data-trg-graph]');
    const accent = root.getAttribute('data-accent') || '#22c55e';
    const NON_PASSING_STATUS_LIMIT = 1000; // large => always show graph
    const container = root.closest('[data-trg-container]');

    /** @type {import('./TestResultsGraph.astro').Props["github"]} */
    const githubCfg = (() => {
      const raw = root.getAttribute('data-github');
      try { return raw ? JSON.parse(raw) : null; } catch { return null; }
    })();

    async function fetchJson(url) {
      const r = await fetch(url, { mode: 'cors' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    }

    function toDateKeyFromName(name) {
      const m = name.match(/^(\d{4}-\d{2}-\d{2})/);
      return m ? m[1] : null;
    }

    function decodeBase64(b64) {
      try { return atob(b64.replace(/\n/g, '')); } catch { return ''; }
    }

    function uint8FromBinary(bin) {
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
      return arr;
    }

    function decodeBufferSmart(buf) {
      try {
        const u8 = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
        if (u8.length >= 2) {
          const bom = (u8[0] << 8) | u8[1];
          if (bom === 0xFEFF) {
            return new TextDecoder('utf-16be').decode(u8);
          } else if (bom === 0xFFFE) {
            return new TextDecoder('utf-16le').decode(u8);
          }
        }
        const utf8 = new TextDecoder('utf-8').decode(u8);
        if (/\u0000/.test(utf8)) {
          try { return new TextDecoder('utf-16le').decode(u8); } catch {}
          try { return new TextDecoder('utf-16be').decode(u8); } catch {}
        }
        return utf8;
      } catch {
        return '';
      }
    }

    function decodeBase64ToTextSmart(b64) {
      try {
        const bin = decodeBase64(b64);
        const u8 = uint8FromBinary(bin);
        return decodeBufferSmart(u8);
      } catch {
        return '';
      }
    }

    function summarizePlaywright(json) {
      let passed = 0, failed = 0, skipped = 0, timedOut = 0, errors = 0;

      function bumpStatus(raw) {
        const s = typeof raw === 'string' ? raw : '';
        if (s === 'passed') { passed++; return; }
        if (s === 'skipped' || s === 'pending') { skipped++; return; }
        if (s === 'failed') { failed++; return; }
        if (s === 'timedOut' || s === 'timeout') { timedOut++; return; }
        if (!s) return;
        failed++;
        errors++;
      }

      function countFromTestLike(test) {
        if (Array.isArray(test.results) && test.results.length) {
          for (const res of test.results) {
            bumpStatus(res.status || test.status);
          }
          return true;
        }
        if (typeof test.status === 'string') {
          bumpStatus(test.status);
          return true;
        }
        return false;
      }
      function walkSuite(suite) {
        if (!suite || typeof suite !== 'object') return;
        if (Array.isArray(suite.specs)) {
          for (const spec of suite.specs) {
            if (Array.isArray(spec.tests)) {
              for (const t of spec.tests) countFromTestLike(t);
            }
          }
        }
        if (Array.isArray(suite.suites)) {
          for (const s of suite.suites) walkSuite(s);
        }
        if (Array.isArray(suite.tests)) {
          for (const t of suite.tests) countFromTestLike(t);
        }
      }
      if (Array.isArray(json?.suites)) {
        for (const s of json.suites) walkSuite(s);
      }
      return { passed, failed, skipped, timedOut, errors };
    }

    function fmtDayLabel(key) {
      const d = new Date(key);
      const opts = { month: 'short', day: 'numeric' };
      return d.toLocaleDateString(undefined, opts);
    }

    function encPath(p) { return (p || '').split('/').map(encodeURIComponent).join('/'); }

    async function loadFromStaticData() {
      const url = githubCfg?.dataUrl;
      if (!url) throw new Error('Missing dataUrl');
      const r = await fetch(url, { mode: 'cors' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const json = await r.json();
      if (Array.isArray(json)) return json;
      if (Array.isArray(json?.runs)) return json.runs;
      throw new Error('Unexpected static data shape');
    }

    async function loadFromGitHub() {
      const { owner, repo, branch, path, days = 7, linkStyle = 'blob' } = githubCfg || {};
      if (!owner || !repo || !branch || !path) throw new Error('Missing config');
      // Start by listing files in the results branch.
      const listUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encPath(path)}?ref=${encodeURIComponent(branch)}`;
      const items = await fetchJson(listUrl);
      if (!Array.isArray(items)) throw new Error('Unexpected listing response');
      const files = items.filter(x => x.type === 'file' && /\.json$/i.test(x.name))
                         .sort((a,b) => a.name.localeCompare(b.name));

      function labelFromFilename(name) {
        const m = name.match(/^(\d{4}-\d{2}-\d{2})(?:T(\d{2}-\d{2}-\d{2})Z)?/);
        if (!m) return name;
        const date = m[1];
        const time = m[2]?.replace(/-/g, ':');
        const d = new Date(date);
        const day = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        return time ? `${day} ${time}` : day;
      }

      async function fetchViaApiRaw(name) {
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encPath(path)}/${encodeURIComponent(name)}?ref=${encodeURIComponent(branch)}`;
        const r = await fetch(url, { mode: 'cors', headers: { Accept: 'application/vnd.github.v3.raw' } });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const buf = await r.arrayBuffer();
        const text = decodeBufferSmart(buf);
        let json = null;
        try { json = JSON.parse(text); }
        catch { try { json = JSON.parse((text || '').replace(/\u0000/g, '')); } catch {}
        }
        return { text, json };
      }

      function heuristicCount(text) {
        const count = (re) => ((text.match(re) || []).length);
        const passed = count(/\bstatus\"\s*:\s*\"passed\"/g) + count(/\boutcome\"\s*:\s*\"expected\"/g) + count(/\bok\"\s*:\s*true\b/g);
        const failed = count(/\bstatus\"\s*:\s*\"failed\"/g) + count(/\boutcome\"\s*:\s*\"unexpected\"/g) + count(/\bok\"\s*:\s*false\b/g);
        const skipped = count(/\bstatus\"\s*:\s*\"skipped\"/g) + count(/\bskipped\"\s*:\s*true\b/g) + count(/\bpending\"\s*:\s*true\b/g);
        const timedOut = count(/\bstatus\"\s*:\s*\"timedOut\"/g) + count(/\btimedout\"\s*:\s*true\b/g);
        const errors = 0;
        return { passed, failed, skipped, timedOut, errors };
      }

      // Group by date and keep the latest run per day
      const byDate = new Map();
      for (const f of files) {
        const key = toDateKeyFromName(f.name);
        if (!key) continue;
        const existing = byDate.get(key);
        if (!existing || f.name > existing.name) byDate.set(key, f);
      }

      // Date keys, sorted
      const allKeys = Array.from(byDate.keys()).sort((a,b) => a.localeCompare(b));
      const limitedKeys = typeof days === 'number' && days > 0 ? allKeys.slice(-days) : allKeys;

      const runs = [];
      for (const key of limitedKeys) {
        const f = byDate.get(key);
        let text = null, json = null;
        try { ({ text, json } = await fetchViaApiRaw(f.name)); } catch {} // try via API raw
        if (!text) {
          // fallback: try via content API
          console.log('!text -> using fallback to fetch results');
          try {
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encPath(path)}/${encodeURIComponent(f.name)}?ref=${encodeURIComponent(branch)}`;
            const details = await fetchJson(url);
            if (details && typeof details.content === 'string' && details.encoding === 'base64') {
              text = decodeBase64ToTextSmart(details.content || '');
              try { json = JSON.parse(text); }
              catch { try { json = JSON.parse((text || '').replace(/\u0000/g, '')); } catch { json = null; } }
              }
            if (!text && details && details.download_url) {
              const r = await fetch(details.download_url, { mode: 'cors' });
              if (r.ok) {
                const buf2 = await r.arrayBuffer();
                text = decodeBufferSmart(buf2);
                }
                try { json = JSON.parse(text || ''); }
                catch { try { json = JSON.parse((text || '').replace(/\u0000/g, '')); } catch { json = null; } }
                }
                } catch {}
              }
        if (!text && f.download_url) {
          // fallback: try via direct download URL
          console.log('!text && f.download_url -> using fallback #2 to download_url');
          try {
            const r = await fetch(f.download_url, { mode: 'cors' });
            if (r.ok) {
              const buf3 = await r.arrayBuffer();
              text = decodeBufferSmart(buf3);
            }
            try { json = JSON.parse(text || ''); }
            catch { try { json = JSON.parse((text || '').replace(/\u0000/g, '')); } catch { json = null; } }
          } catch {}
        }
        if (!text) continue;

        let counts = json ? summarizePlaywright(json) : { passed: 0, failed: 0, skipped: 0 };
        if ((counts.passed + counts.failed + counts.skipped + (counts.timedOut || 0)) === 0) {
          counts = heuristicCount((text || '').replace(/\u0000/g, ''));
        }
        const link = linkStyle === 'raw' && f.download_url ? f.download_url : `https://github.com/${owner}/${repo}/blob/${encodeURIComponent(branch)}/${path}/${encodeURIComponent(f.name)}`;
        runs.push({ key, label: fmtDayLabel(key), link, ...counts });
      }
      return runs;
    }

    function failureCount(run) {
      const failed = Number(run?.failed || 0);
      const timedOut = Number(run?.timedOut || run?.timeout || 0);
      const errors = Number(run?.errors || 0);
      // return failed + timedOut + errors;
      return failed + errors;
    }

    function renderBars(data) {
      if (!graphEl) return;
      const maxTotal = Math.max(1, ...data.map(d => d.passed + failureCount(d)));
      const html = `
        <div class="flex gap-3 items-end overflow-x-auto pb-2">
          ${data.map(d => {
            const failures = failureCount(d);
            const total = d.passed + failures;
            const passPct = total ? (d.passed / maxTotal) * 100 : 0;
            const failPct = total ? (failures / maxTotal) * 100 : 0;
            return `
              <a href="${d.link}" target="_blank" rel="noopener noreferrer" class="group flex flex-col items-center min-w-[36px]">
                <div class="w-6 sm:w-7 md:w-8 h-32 bg-gray-100 border border-gray-200 rounded-md overflow-hidden flex flex-col-reverse">
                  <div title="${d.passed} passed" style="height:${passPct}%; background:${accent};" class="transition-all"></div>
                  <div title="${failures} failed" style="height:${failPct}%; background:#ef4444;" class="transition-all"></div>
                </div>
                <div class="mt-2 text-xs text-gray-600">${d.label}</div>
                <div class="text-[10px] text-gray-500">${d.passed}✓ / ${failures}✗</div>
              </a>
            `;
          }).join('')}
        </div>
      `;
      graphEl.innerHTML = html;
      graphEl.hidden = false;
    }

    (async () => {
      try {
        const usingStatic = !!githubCfg?.dataUrl;
        console.log(usingStatic ? 'Test Results: fetched data pre-build' : 'Test Results: fetching from GitHub', githubCfg);
        statusEl.textContent = usingStatic ? 'Loading results…' : 'Fetching from GitHub…';
        const data = usingStatic ? await loadFromStaticData() : await loadFromGitHub();
        if (!data.length) {
          statusEl.textContent = 'No test results found.';
          return;
        }

        const totals = data.reduce((acc, run) => {
          acc.failed += Number(run.failed || 0);
          acc.skipped += Number(run.skipped || 0);
          acc.timedOut += Number(run.timedOut || run.timeout || 0);
          acc.errors += Number(run.errors || 0);
          return acc;
        }, { failed: 0, skipped: 0, timedOut: 0, errors: 0 });

        const noisyStatuses = totals.failed + totals.skipped + totals.timedOut + totals.errors;
        if (noisyStatuses > NON_PASSING_STATUS_LIMIT) {
          if (container) container.remove();
          return;
        }

        statusEl.hidden = true;
        renderBars(data);
      } catch (e) {
        statusEl.textContent = `Failed to load results: ${e}`;
      }
    })();
  }

  function initAll() {
    document.querySelectorAll('[data-trg-root]').forEach(initOne);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll, { once: true });
  } else {
    initAll();
  }
</script>

